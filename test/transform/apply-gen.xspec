<?xml version="1.0" encoding="utf-8"?>
<!--
  Tests dynamic function application boilerplate generation

  Copyright (C) 2014 LoVullo Associates, Inc.

    This file is part of hoxsl.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<description xmlns="http://www.jenitennison.com/xslt/xspec"
             xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
             xmlns:f="http://www.lovullo.com/hoxsl/apply"
             xmlns:foo="http://www.lovullo.com/_junk"
             stylesheet="apply-gen-test.xsl">

  <!-- basic case -->
  <scenario label="given a unary function">
    <context>
      <xsl:stylesheet>
        <xsl:function name="foo:bar">
          <xsl:param name="foo" />
        </xsl:function>
      </xsl:stylesheet>
    </context>

    <expect label="generates a function of the same name"
            test="xsl:stylesheet/xsl:function/@name = 'foo:bar'" />

    <expect label="generates function of type `element()'"
            test="xsl:stylesheet/xsl:function/@as = 'element()'" />

    <!-- this function is used to generate an element for later
         application -->
    <expect label="generated function is nullary"
            test="count( xsl:stylesheet/xsl:function/xsl:param ) = 0" />

    <!-- the generated node is simply the same name and namespace as
         the function -->
    <expect label="generated function produces function node"
            test="exists( xsl:stylesheet/xsl:function/foo:bar )" />


    <!-- more detailed tests below -->
    <expect label="generates application template"
            test="xsl:stylesheet/xsl:template/@match = 'foo:bar'" />

    <expect label="generated template has mode f:apply"
            test="xsl:stylesheet/xsl:template/@mode = 'f:apply'" />
  </scenario>


  <!-- we'll test the application directly; we won't parse the output,
       since that is error-prone, fragile, and misses the poin  -->
  <scenario label="application templates">
    <scenario label="of N-ary functions">
      <context>
        <xsl:stylesheet>
          <xsl:function name="foo:bar">
            <xsl:param name="a" />
            <xsl:param name="b" as="xs:decimal" />
            <xsl:param name="c" />"
          </xsl:function>
        </xsl:stylesheet>
      </context>

      <expect label="yields N template parameters"
              test="count( xsl:stylesheet/xsl:template/xsl:param )
                    = 3" />

      <!-- important for application! -->
      <expect label="template parameter names are sequential"
              test="xsl:stylesheet/xsl:template/xsl:param
                      /@name = concat( 'arg', position() )" />

      <expect label="mirrors params without @as"
              test="not( xsl:stylesheet/xsl:template
                      /xsl:param[ 1 ]/@as )" />

      <expect label="mirrors params with @as"
              test="xsl:stylesheet/xsl:template
                      /xsl:param[ 2 ]/@as = 'xs:decimal'" />
    </scenario>
  </scenario>


  <!-- if a function is nullary, then it is either a thunk or used for
       its side-effects; we expect the user to take appropriate
       caution -->
  <scenario label="given a nullary function">
    <context>
      <xsl:stylesheet>
        <xsl:function name="foo:bar">
          <foo:thunk />
        </xsl:function>
      </xsl:stylesheet>
    </context>

    <!-- generating one would conflict, of couse -->
    <expect label="does not generate a function"
            test="not( xsl:stylesheet/xsl:function )" />
  </scenario>


  <scenario label="given a stylesheet">
    <scenario label="with no function elements">
      <context>
        <xsl:stylesheet>
          <xsl:template name="foo" />
          <xsl:template name="bar" />
        </xsl:stylesheet>
      </context>

      <expect label="produces an empty stylesheet"
              context="xsl:stylesheet">
        <xsl:stylesheet version="2.0" />
      </expect>
    </scenario>
  </scenario>


  <!-- xsl:transform is an alternative to xsl:stylesheet -->
  <scenario label="given a xsl:template root note">
    <context>
      <xsl:transform />
    </context>

    <expect label="properly outputs stylesheet"
            context="xsl:stylesheet">
      <xsl:stylesheet version="2.0" />
    </expect>
  </scenario>


  <!-- This actually tests the generated stylesheet to ensure proper
       execution.  We test by invoking the application template with
       the result of the generated nullary.  We expect that the
       application template will apply the arguments to the proper
       function and return the result of the expected type.

       You can't see it here (check the imported stylesheet), but
       `foo:apply-add-two' defines a return type, so we also ensure
       that such type data are retained.

       Exciting! -->
  <scenario label="given a generated document">
    <scenario label="with a processed function">
      <!-- calling the generated nullary -->
      <call function="foo:apply-add-two">
        <param name="x" select="2" />
        <param name="y" select="3" />
      </call>

      <expect label="applying template to nullary yields proper result"
              test="$x:result = 5" />
    </scenario>


    <!-- ensure that multiple functions are processed -->
    <scenario label="with multiple functions">
      <call function="foo:apply-sub-two">
        <param name="x" select="2" />
        <param name="y" select="3" />
      </call>

      <expect label="applying template to nullary yields proper result"
              test="$x:result = -1" />
    </scenario>


    <!-- note that this _does not_ test f:arity itself: it is intended
         to test that the arity datum is properly generated -->
    <scenario label="f:arity">
      <call function="f:arity">
        <param name="fnref" select="foo:sub-two()" />
      </call>"

      <expect label="is able to determine arity"
              test="$x:result = 2" />
    </scenario>
  </scenario>
</description>
